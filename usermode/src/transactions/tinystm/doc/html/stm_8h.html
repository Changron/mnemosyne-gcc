<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TinySTM: stm.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>stm.h File Reference</h1>STM functions.  
<a href="#_details">More...</a>
<p>

<p>
<a href="stm_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstm__tx__attr.html">stm_tx_attr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction attributes specified by the application.  <a href="structstm__tx__attr.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uintptr_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of a word (accessible atomically) on the target architecture.  <a href="#571736ccf3baeb79b32e66efd03f2ff0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f969a019d50865dee2bac2269af19dc"></a><!-- doxytag: member="stm.h::stm_tx_attr_t" ref="5f969a019d50865dee2bac2269af19dc" args="" -->
typedef struct <a class="el" href="structstm__tx__attr.html">stm_tx_attr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#5f969a019d50865dee2bac2269af19dc">stm_tx_attr_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction attributes specified by the application. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#9dfcb42f2a39f6b806454a255ad50e4f">stm_init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the STM library.  <a href="#9dfcb42f2a39f6b806454a255ad50e4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#23b7b67a612502b082a6e324a5b4218d">stm_exit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up the STM library.  <a href="#23b7b67a612502b082a6e324a5b4218d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#9489359650ffb7ea4d2e1431491b27ee">stm_init_thread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a transactional thread.  <a href="#9489359650ffb7ea4d2e1431491b27ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#e361e754dc0aa0b54ed4e5b3ba15f06b">stm_exit_thread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clean up a transactional thread.  <a href="#e361e754dc0aa0b54ed4e5b3ba15f06b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#9ae0dfa50a19c3f671467a38c64c6d33">stm_start</a> (sigjmp_buf *env, <a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a transaction.  <a href="#9ae0dfa50a19c3f671467a38c64c6d33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#2307b5aa456731bcd92a2dc481258f89">stm_commit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to commit a transaction.  <a href="#2307b5aa456731bcd92a2dc481258f89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#b41c41f602357da9f064ee817e503bec">stm_abort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly abort a transaction.  <a href="#b41c41f602357da9f064ee817e503bec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#473026557b3911a3af8b1b2fc4cc426c">stm_load</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional load.  <a href="#473026557b3911a3af8b1b2fc4cc426c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#5a822c0df0ff5938016674955e7ae99e">stm_store</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional store.  <a href="#5a822c0df0ff5938016674955e7ae99e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#77218104875612813d7f2791ac343cf6">stm_store2</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transactional store.  <a href="#77218104875612813d7f2791ac343cf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#e2cafb5bccc1c71ceed7cd3f0b6c5fc6">stm_active</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current transaction is still active.  <a href="#e2cafb5bccc1c71ceed7cd3f0b6c5fc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#017b9b17faf18324ccd22c4369c86a53">stm_aborted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the current transaction has aborted.  <a href="#017b9b17faf18324ccd22c4369c86a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">sigjmp_buf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ae58c1c5e363ae7e2ddc22f1208c7256">stm_get_env</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the environment used by the current thread to jump back upon abort.  <a href="#ae58c1c5e363ae7e2ddc22f1208c7256"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#d2d9401a5819a26dc4f4992a3d2cb529">stm_get_attributes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get attributes associated with the current transactions, if any.  <a href="#d2d9401a5819a26dc4f4992a3d2cb529"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#aa4e7819e2e3eebec0406555a2ea4502">stm_get_stats</a> (const char *name, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get various statistics about the current thread/transaction.  <a href="#aa4e7819e2e3eebec0406555a2ea4502"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ac7f1c4dd5f948f23a2f4df0a7d530d6">stm_get_parameter</a> (const char *name, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get various parameters of the STM library.  <a href="#ac7f1c4dd5f948f23a2f4df0a7d530d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#bca06bb60ae936118c769f6fdd41530c">stm_set_parameter</a> (const char *name, void *val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set various parameters of the STM library.  <a href="#bca06bb60ae936118c769f6fdd41530c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#fbb66f0208d71702f6dfb304b9628594">stm_create_specific</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a key to associate application-specific data to the current thread/transaction.  <a href="#fbb66f0208d71702f6dfb304b9628594"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#c8b66dbadfd62e541409823d1b80aba7">stm_get_specific</a> (int key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get application-specific data associated to the current thread/transaction and a given key.  <a href="#c8b66dbadfd62e541409823d1b80aba7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#cf336ae279fd83cf1195bd76aea01df7">stm_set_specific</a> (int key, void *data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set application-specific data associated to the current thread/transaction and a given key.  <a href="#cf336ae279fd83cf1195bd76aea01df7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#54fcf0b2074258b824b60c395083ed4d">stm_register</a> (void(*on_thread_init)(void *arg), void(*on_thread_exit)(void *arg), void(*on_start)(void *arg), void(*on_commit)(void *arg), void(*on_abort)(void *arg), void *arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register application-specific callbacks that are triggered when particular events occur.  <a href="#54fcf0b2074258b824b60c395083ed4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#c932e2cd9b2b1621326d281329362bfc">stm_unit_load</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe load.  <a href="#c932e2cd9b2b1621326d281329362bfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#ec9492eba41d0df151c30fc559a14957">stm_unit_store</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe store.  <a href="#ec9492eba41d0df151c30fc559a14957"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#328faa38ec6bf579ba6fd166765a7527">stm_unit_store2</a> (volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *addr, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> value, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> mask, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transaction-safe store.  <a href="#328faa38ec6bf579ba6fd166765a7527"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#9ca153a890bb4daff693a21897834301">stm_set_extension</a> (int enable, <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *timestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot.  <a href="#9ca153a890bb4daff693a21897834301"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="stm_8h.html#30979ab656135fe712adffcbeed80e15">stm_get_clock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the current value of the global clock (used for timestamps).  <a href="#30979ab656135fe712adffcbeed80e15"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
STM functions. 
<p>
This library contains the core functions for programming with STM. <dl class="author" compact><dt><b>Author:</b></dt><dd>Pascal Felber &lt;<a href="mailto:pascal.felber@unine.ch">pascal.felber@unine.ch</a>&gt; </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>2007-2009 </dd></dl>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="571736ccf3baeb79b32e66efd03f2ff0"></a><!-- doxytag: member="stm.h::stm_word_t" ref="571736ccf3baeb79b32e66efd03f2ff0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of a word (accessible atomically) on the target architecture. 
<p>
The library supports 32-bit and 64-bit architectures. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b41c41f602357da9f064ee817e503bec"></a><!-- doxytag: member="stm.h::stm_abort" ref="b41c41f602357da9f064ee817e503bec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_abort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Explicitly abort a transaction. 
<p>
Execution continues at the point specified by the environment passed as parameter to <a class="el" href="stm_8h.html#9ae0dfa50a19c3f671467a38c64c6d33" title="Start a transaction.">stm_start()</a> (for the outermost transaction upon nesting), unless the environment was null. 
</div>
</div><p>
<a class="anchor" name="017b9b17faf18324ccd22c4369c86a53"></a><!-- doxytag: member="stm.h::stm_aborted" ref="017b9b17faf18324ccd22c4369c86a53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_aborted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current transaction has aborted. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True (non-zero) if the transaction has aborted, false (zero) otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2cafb5bccc1c71ceed7cd3f0b6c5fc6"></a><!-- doxytag: member="stm.h::stm_active" ref="e2cafb5bccc1c71ceed7cd3f0b6c5fc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_active           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if the current transaction is still active. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True (non-zero) if the transaction is active, false (zero) otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2307b5aa456731bcd92a2dc481258f89"></a><!-- doxytag: member="stm.h::stm_commit" ref="2307b5aa456731bcd92a2dc481258f89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_commit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Try to commit a transaction. 
<p>
If successful, the function returns 1. Otherwise, execution continues at the point specified by the environment passed as parameter to <a class="el" href="stm_8h.html#9ae0dfa50a19c3f671467a38c64c6d33" title="Start a transaction.">stm_start()</a> (for the outermost transaction upon nesting). If the environment was null, the function returns 0 if commit is unsuccessful. 
</div>
</div><p>
<a class="anchor" name="fbb66f0208d71702f6dfb304b9628594"></a><!-- doxytag: member="stm.h::stm_create_specific" ref="fbb66f0208d71702f6dfb304b9628594" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_create_specific           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a key to associate application-specific data to the current thread/transaction. 
<p>
This mechanism can be combined with callbacks to write modules.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new key. </dd></dl>

</div>
</div><p>
<a class="anchor" name="23b7b67a612502b082a6e324a5b4218d"></a><!-- doxytag: member="stm.h::stm_exit" ref="23b7b67a612502b082a6e324a5b4218d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up the STM library. 
<p>
This function must be called once, from the main thread, after all transactional threads have completed. 
</div>
</div><p>
<a class="anchor" name="e361e754dc0aa0b54ed4e5b3ba15f06b"></a><!-- doxytag: member="stm.h::stm_exit_thread" ref="e361e754dc0aa0b54ed4e5b3ba15f06b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_exit_thread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up a transactional thread. 
<p>
This function must be called once from each thread that performs transactional operations, upon exit. 
</div>
</div><p>
<a class="anchor" name="d2d9401a5819a26dc4f4992a3d2cb529"></a><!-- doxytag: member="stm.h::stm_get_attributes" ref="d2d9401a5819a26dc4f4992a3d2cb529" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a>* stm_get_attributes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get attributes associated with the current transactions, if any. 
<p>
These attributes were passed as parameters when starting the transaction.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Attributes associated with the current transaction, or NULL if no attributes were specified when starting the transaction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="30979ab656135fe712adffcbeed80e15"></a><!-- doxytag: member="stm.h::stm_get_clock" ref="30979ab656135fe712adffcbeed80e15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_get_clock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the current value of the global clock (used for timestamps). 
<p>
This function is useful when programming with unit loads and stores.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Value of the global clock. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae58c1c5e363ae7e2ddc22f1208c7256"></a><!-- doxytag: member="stm.h::stm_get_env" ref="ae58c1c5e363ae7e2ddc22f1208c7256" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigjmp_buf* stm_get_env           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the environment used by the current thread to jump back upon abort. 
<p>
This environment should be used when calling sigsetjmp() before starting the transaction and passed as parameter to <a class="el" href="stm_8h.html#9ae0dfa50a19c3f671467a38c64c6d33" title="Start a transaction.">stm_start()</a>. If the current thread is already executing a transaction, i.e., the new transaction will be nested, the function returns NULL and one should not call sigsetjmp().<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The environment to use for saving the stack context, or NULL if the transaction is nested. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac7f1c4dd5f948f23a2f4df0a7d530d6"></a><!-- doxytag: member="stm.h::stm_get_parameter" ref="ac7f1c4dd5f948f23a2f4df0a7d530d6" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_parameter           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get various parameters of the STM library. 
<p>
See the source code (stm.c) for a list of supported parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the variable that should hold the value of the parameter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8b66dbadfd62e541409823d1b80aba7"></a><!-- doxytag: member="stm.h::stm_get_specific" ref="c8b66dbadfd62e541409823d1b80aba7" args="(int key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* stm_get_specific           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get application-specific data associated to the current thread/transaction and a given key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key designating the data to read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Data stored under the given key. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa4e7819e2e3eebec0406555a2ea4502"></a><!-- doxytag: member="stm.h::stm_get_stats" ref="aa4e7819e2e3eebec0406555a2ea4502" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_get_stats           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get various statistics about the current thread/transaction. 
<p>
See the source code (stm.c) for a list of supported statistics.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the statistics. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to the variable that should hold the value of the statistics. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9dfcb42f2a39f6b806454a255ad50e4f"></a><!-- doxytag: member="stm.h::stm_init" ref="9dfcb42f2a39f6b806454a255ad50e4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_init           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the STM library. 
<p>
This function must be called once, from the main thread, before any access to the other functions of the library. 
</div>
</div><p>
<a class="anchor" name="9489359650ffb7ea4d2e1431491b27ee"></a><!-- doxytag: member="stm.h::stm_init_thread" ref="9489359650ffb7ea4d2e1431491b27ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_init_thread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a transactional thread. 
<p>
This function must be called once from each thread that performs transactional operations, before the thread calls any other functions of the library. 
</div>
</div><p>
<a class="anchor" name="473026557b3911a3af8b1b2fc4cc426c"></a><!-- doxytag: member="stm.h::stm_load" ref="473026557b3911a3af8b1b2fc4cc426c" args="(volatile stm_word_t *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_load           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transactional load. 
<p>
Read the specified memory location in the context of the current transaction and return its value. Upon conflict, the transaction may abort while reading the memory location. Note that the value returned is consistent with respect to previous reads from the same transaction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Value read from the specified address. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54fcf0b2074258b824b60c395083ed4d"></a><!-- doxytag: member="stm.h::stm_register" ref="54fcf0b2074258b824b60c395083ed4d" args="(void(*on_thread_init)(void *arg), void(*on_thread_exit)(void *arg), void(*on_start)(void *arg), void(*on_commit)(void *arg), void(*on_abort)(void *arg), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_register           </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_thread_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_thread_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_commit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&nbsp;</td>
          <td class="paramname"> <em>on_abort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register application-specific callbacks that are triggered when particular events occur. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>on_thread_init</em>&nbsp;</td><td>Function called upon initialization of a transactional thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_thread_exit</em>&nbsp;</td><td>Function called upon cleanup of a transactional thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_start</em>&nbsp;</td><td>Function called upon start of a transaction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_commit</em>&nbsp;</td><td>Function called upon successful transaction commit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>on_abort</em>&nbsp;</td><td>Function called upon transaction abort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>Parameter to be passed to the callback functions. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the callbacks have been successfully registered, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ca153a890bb4daff693a21897834301"></a><!-- doxytag: member="stm.h::stm_set_extension" ref="9ca153a890bb4daff693a21897834301" args="(int enable, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_extension           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable snapshot extensions for the current transaction, and optionally set an upper bound for the snapshot. 
<p>
This function is useful for implementing efficient algorithms with unit loads and stores while preserving compatibility with with regular transactions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True (non-zero) to enable snapshot extensions, false (zero) to disable them. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than the current upper bound of the snapshot, update the upper bound to the value of the referenced variable. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bca06bb60ae936118c769f6fdd41530c"></a><!-- doxytag: member="stm.h::stm_set_parameter" ref="bca06bb60ae936118c769f6fdd41530c" args="(const char *name, void *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_set_parameter           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set various parameters of the STM library. 
<p>
See the source code (stm.c) for a list of supported parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Pointer to a variable that holds the new value of the parameter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 upon success, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf336ae279fd83cf1195bd76aea01df7"></a><!-- doxytag: member="stm.h::stm_set_specific" ref="cf336ae279fd83cf1195bd76aea01df7" args="(int key, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_set_specific           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set application-specific data associated to the current thread/transaction and a given key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key designating the data to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data to store under the given key. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ae0dfa50a19c3f671467a38c64c6d33"></a><!-- doxytag: member="stm.h::stm_start" ref="9ae0dfa50a19c3f671467a38c64c6d33" args="(sigjmp_buf *env, stm_tx_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_start           </td>
          <td>(</td>
          <td class="paramtype">sigjmp_buf *&nbsp;</td>
          <td class="paramname"> <em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstm__tx__attr.html">stm_tx_attr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start a transaction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>env</em>&nbsp;</td><td>Specifies the environment (stack context) to be used to jump back upon abort. If null, the transaction will continue even after abort and the application should explicitely check its status. If the transaction is nested, this parameter is ignored as an abort will restart the top-level transaction (flat nesting). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Specifies optional attributes associated to the transaction. If null, the transaction uses default attributes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a822c0df0ff5938016674955e7ae99e"></a><!-- doxytag: member="stm.h::stm_store" ref="5a822c0df0ff5938016674955e7ae99e" args="(volatile stm_word_t *addr, stm_word_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transactional store. 
<p>
Write a word-sized value to the specified memory location in the context of the current transaction. Upon conflict, the transaction may abort while writing to the memory location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77218104875612813d7f2791ac343cf6"></a><!-- doxytag: member="stm.h::stm_store2" ref="77218104875612813d7f2791ac343cf6" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stm_store2           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transactional store. 
<p>
Write a value to the specified memory location in the context of the current transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. Upon conflict, the transaction may abort while writing to the memory location.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask specifying the bits to be written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c932e2cd9b2b1621326d281329362bfc"></a><!-- doxytag: member="stm.h::stm_unit_load" ref="c932e2cd9b2b1621326d281329362bfc" args="(volatile stm_word_t *addr, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> stm_unit_load           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transaction-safe load. 
<p>
Read the specified memory location outside of the context of any transaction and return its value. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null, the referenced variable is updated to hold the timestamp of the memory location being read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Value read from the specified address. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec9492eba41d0df151c30fc559a14957"></a><!-- doxytag: member="stm.h::stm_unit_store" ref="ec9492eba41d0df151c30fc559a14957" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transaction-safe store. 
<p>
Write a word-sized value to the specified memory location outside of the context of any transaction. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="328faa38ec6bf579ba6fd166765a7527"></a><!-- doxytag: member="stm.h::stm_unit_store2" ref="328faa38ec6bf579ba6fd166765a7527" args="(volatile stm_word_t *addr, stm_word_t value, stm_word_t mask, stm_word_t *timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stm_unit_store2           </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stm_8h.html#571736ccf3baeb79b32e66efd03f2ff0">stm_word_t</a> *&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transaction-safe store. 
<p>
Write a value to the specified memory location outside of the context of any transaction. The value may be smaller than a word on the target architecture, in which case a mask is used to indicate the bits of the words that must be updated. The operation behaves as if executed in the context of a dedicated transaction (i.e., it executes atomically and in isolation) that never aborts, but may get delayed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Address of the memory location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>Mask specifying the bits to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>If non-null and the timestamp in the referenced variable is smaller than that of the memory location being written, no data is actually written and the variable is updated to hold the more recent timestamp. If non-null and the timestamp in the referenced variable is not smaller than that of the memory location being written, the memory location is written and the variable is updated to hold the new timestamp. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if value has been written, 0 otherwise. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jan 28 18:03:07 2009 for TinySTM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
